/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// linkNodesInCanvasIndex.ts
var linkNodesInCanvasIndex_exports = {};
__export(linkNodesInCanvasIndex_exports, {
  default: () => LinkNodesInCanvas
});
module.exports = __toCommonJS(linkNodesInCanvasIndex_exports);
var import_obsidian = require("obsidian");
var LinkNodesInCanvas = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "link-between-selection-nodes",
      name: "Link Between Selection Nodes",
      checkCallback: (checking) => {
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
          if (!checking) {
            const canvas = canvasView.canvas;
            const selection = canvas.selection;
            const fileNodes = Array.from(selection).filter((node) => (node == null ? void 0 : node.filePath) !== void 0);
            if (fileNodes.length === 0)
              return;
            const resolvedLinks = app.metadataCache.resolvedLinks;
            fileNodes.forEach((node) => {
              const allLinks = Object.keys(resolvedLinks[node.filePath]);
              for (let i = 0; i < fileNodes.length; i++) {
                if (allLinks.includes(fileNodes[i].filePath)) {
                  if (node !== fileNodes[i])
                    this.createEdge(node, fileNodes[i], canvas);
                }
              }
              canvas.requestSave();
            });
          }
          return true;
        }
      }
    });
  }
  createEdge(node1, node2, canvas) {
    var _a;
    const random = (e) => {
      let t = [];
      for (let n = 0; n < e; n++) {
        t.push((16 * Math.random() | 0).toString(16));
      }
      return t.join("");
    };
    const edge = canvas.edges.get((_a = canvas.getData().edges.first()) == null ? void 0 : _a.id);
    if (edge) {
      const tempEdge = new edge.constructor(canvas, random(16), { side: "right", node: node1 }, { side: "left", node: node2 });
      canvas.addEdge(tempEdge);
      tempEdge.attach();
      tempEdge.render();
    } else {
      new import_obsidian.Notice("You should have at least one edge in the canvas to use this command.");
    }
  }
  onunload() {
  }
};
