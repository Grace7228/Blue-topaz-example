/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => ChatViewPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var KEYMAP = { ">": "right", "<": "left", "^": "center" };
var COLORS = ["red", "orange", "yellow", "green", "blue", "purple", "grey", "brown", "indigo", "teal"];
var HEADERS = ["h2", "h3", "h4", "h5", "h6"];
var MAX_WIDTHS = ["50", "55", "60", "65", "70", "75", "80", "85", "90"];
var _ChatPatterns = class {
};
var ChatPatterns = _ChatPatterns;
ChatPatterns.message = /(^>|<|\^)/;
ChatPatterns.delimiter = /.../;
ChatPatterns.comment = /^#/;
ChatPatterns.colors = /\[(.*?)\]/;
ChatPatterns.format = /{(.*?)}/;
ChatPatterns.joined = RegExp([_ChatPatterns.message, _ChatPatterns.delimiter, _ChatPatterns.colors, _ChatPatterns.comment, _ChatPatterns.format].map((pattern) => pattern.source).join("|"));
var ChatViewPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      this.registerMarkdownCodeBlockProcessor("chat", (source, el, _) => {
        const rawLines = source.split("\n").filter((line) => ChatPatterns.joined.test(line.trim()));
        const lines = rawLines.map((rawLine) => rawLine.trim());
        const formatConfigs = new Map();
        const colorConfigs = new Map();
        for (const line of lines) {
          if (ChatPatterns.format.test(line)) {
            const configs = line.replace("{", "").replace("}", "").split(",").map((l) => l.trim());
            for (const config of configs) {
              const entry = config.split("=").map((c) => c.trim());
              if (entry[0] == "header" && HEADERS.contains(entry[1])) {
                formatConfigs.set("header", entry[1]);
              } else if (entry[0] == "mw" && MAX_WIDTHS.contains(entry[1])) {
                formatConfigs.set("mw", entry[1]);
              }
            }
          } else if (ChatPatterns.colors.test(line)) {
            const configs = line.replace("[", "").replace("]", "").split(",").map((l) => l.trim());
            for (const config of configs) {
              const entry = config.split("=").map((c) => c.trim());
              if (entry[0].length > 0 && COLORS.contains(entry[1])) {
                colorConfigs.set(entry[0], entry[1]);
              }
            }
          }
        }
        let continuedCount = 0;
        for (let index = 0; index < lines.length; index++) {
          const line = lines[index].trim();
          if (ChatPatterns.comment.test(line)) {
            el.createEl("p", { text: line.substring(1).trim(), cls: ["chat-view-comment"] });
          } else if (line === "...") {
            const delimiter = el.createDiv({ cls: ["delimiter"] });
            for (let i = 0; i < 3; i++)
              delimiter.createDiv({ cls: ["dot"] });
          } else if (ChatPatterns.message.test(line)) {
            const components = line.substring(1).split("|");
            if (components.length > 0) {
              const first = components[0];
              const header = components.length > 1 ? first.trim() : "";
              const message = components.length > 1 ? components[1].trim() : first.trim();
              const subtext = components.length > 2 ? components[2].trim() : "";
              const continued = index > 0 && line.charAt(0) === lines[index - 1].charAt(0) && header === "";
              let prevHeader = "";
              if (continued) {
                continuedCount++;
                const prevComponents = lines[index - continuedCount].trim().substring(1).split("|");
                prevHeader = prevComponents[0].length > 1 ? prevComponents[0].trim() : "";
              } else {
                continuedCount = 0;
              }
              this.createChatBubble(header, prevHeader, message, subtext, KEYMAP[line.charAt(0)], el, continued, colorConfigs, formatConfigs);
            }
          }
        }
      });
    });
  }
  createChatBubble(header, prevHeader, message, subtext, align, element, continued, colorConfigs, formatConfigs) {
    const marginClass = continued ? "chat-view-small-vertical-margin" : "chat-view-default-vertical-margin";
    const colorConfigClass = `chat-view-${colorConfigs.get(continued ? prevHeader : header)}`;
    const widthClass = formatConfigs.has("mw") ? `chat-view-max-width-${formatConfigs.get("mw")}` : import_obsidian.Platform.isMobile ? "chat-view-mobile-width" : "chat-view-desktop-width";
    const headerEl = formatConfigs.has("header") ? formatConfigs.get("header") : "h4";
    const bubble = element.createDiv({
      cls: ["chat-view-bubble", `chat-view-align-${align}`, marginClass, colorConfigClass, widthClass]
    });
    if (header.length > 0)
      bubble.createEl(headerEl, { text: header, cls: ["chat-view-header"] });
    if (message.length > 0)
      bubble.createEl("p", { text: message, cls: ["chat-view-message"] });
    if (subtext.length > 0)
      bubble.createEl("sub", { text: subtext, cls: ["chat-view-subtext"] });
  }
};
